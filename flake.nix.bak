{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    disko = {
      url = "github:nix-community/disko";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    vscode-server = {
      url = "github:nix-community/nixos-vscode-server";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    kubenix = {
      url = "github:hall/kubenix";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    agenix = {
      url = "github:ryantm/agenix";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    juicefs-csi-driver = {
      url = "github:juicedata/juicefs-csi-driver";
      flake = false;
    };
  };

  outputs =
    {
      self,
      nixpkgs,
      disko,
      vscode-server,
      kubenix,
      agenix,
      ...
    }:
    let
      # Configuration variables
      hostName = "k3s-dev"; # Replace with desired hostname
      domain = "batonac.com"; # Replace with your domain
      fqdn = "${hostName}.${domain}"; # Fully qualified domain name
      diskDevice = "/dev/sda"; # Replace with your disk device
      timeZone = "America/New_York"; # Replace with your timezone
      locale = "en_US.UTF-8"; # Replace with your locale
      username = "nixos"; # Replace with desired username
      initialPassword = "password"; # Replace with a secure password
      ipAddress = "10.48.4.181";
      stateVersion = "25.11"; # NixOS state version
      sshKey = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOv4SpIhHJqtRaYBRQOin4PTDUxRwo7ozoQHTUFjMGLW avunu@AvunuCentral"; # Replace with your SSH public key
      extraPackages = with nixpkgs.legacyPackages.x86_64-linux; [
        coreutils
        curl
        kubectl
        kubernetes-helm
        nettools
        nixfmt-rfc-style
        openssl
        service-wrapper
        wget
      ];
    in
    {
      # Kubenix package for generating Kubernetes manifests
      packages.x86_64-linux.kubenix-manifests =
        (kubenix.evalModules.x86_64-linux {
          module =
            { kubenix, ... }:
            {
              imports = [ kubenix.modules.k8s ];
              kubenix.project = "k3s-dev";
              kubernetes.version = "1.28";

              kubernetes.resources = {
                # Test namespace
                namespaces.test = { };

                # Cert-manager namespace
                namespaces.cert-manager = { };

                # JuiceFS CSI namespace
                namespaces.juicefs-csi = { };

                # Simple test pod
                pods.alpine-test = {
                  metadata.namespace = "default";
                  spec = {
                    containers.alpine = {
                      image = "alpine:latest";
                      command = [
                        "sleep"
                        "3600"
                      ];
                      imagePullPolicy = "IfNotPresent";
                      resources = {
                        requests = {
                          cpu = "100m";
                          memory = "64Mi";
                        };
                      };
                    };
                    restartPolicy = "Always";
                  };
                };

                # Example deployment for testing
                deployments.nginx = {
                  metadata.namespace = "default";
                  spec = {
                    replicas = 2;
                    selector.matchLabels.app = "nginx";
                    template = {
                      metadata.labels.app = "nginx";
                      spec = {
                        containers.nginx = {
                          image = "nginx:1.25";
                          imagePullPolicy = "IfNotPresent";
                          ports = [
                            {
                              containerPort = 80;
                            }
                          ];
                        };
                      };
                    };
                  };
                };

                # Service for nginx
                services.nginx = {
                  metadata.namespace = "default";
                  spec = {
                    selector.app = "nginx";
                    ports = [
                      {
                        name = "http";
                        port = 80;
                        targetPort = 80;
                      }
                    ];
                    type = "ClusterIP";
                  };
                };
              };
            };
        }).config.kubernetes.result;

      # Development shell with secret management tools
      devShells.x86_64-linux.default = nixpkgs.legacyPackages.x86_64-linux.mkShell {
        buildInputs = with nixpkgs.legacyPackages.x86_64-linux; [
          agenix.packages.x86_64-linux.default
          ssh-to-age
          age
          openssh
          openssl
          nixfmt-rfc-style
        ];

        shellHook = ''
          echo "üîê NixOS K8s Secrets Management Shell"
          echo ""
          echo "Available tools:"
          echo "  agenix       - Encrypt/decrypt secrets"
          echo "  ssh-to-age   - Convert SSH keys to age format"
          echo "  age          - Age encryption tool"
          echo ""
          echo "Scripts:"
          echo "  ./setup-secrets.sh - Create encrypted secrets"
          echo "  ./get-age-key.sh   - Get system age key"
          echo ""
          echo "Usage:"
          echo "  1. Run: ./setup-secrets.sh"
          echo "  2. Then: ./update.sh"
          echo ""
        '';
      };

      nixosConfigurations = {
        "${hostName}" = nixpkgs.lib.nixosSystem {
          system = "x86_64-linux";
          modules = [
            { nix.nixPath = [ "nixpkgs=${self.inputs.nixpkgs}" ]; }
            vscode-server.nixosModules.default
            disko.nixosModules.disko
            agenix.nixosModules.default
            (
              {
                config,
                lib,
                pkgs,
                modulesPath,
                ...
              }:
              {
                imports = [
                  (modulesPath + "/profiles/qemu-guest.nix")
                ];

                boot = {
                  initrd = {
                    availableKernelModules = [
                      "ahci"
                      "ehci_pci"
                      "nvme"
                      "uhci_hcd"
                    ];
                    network = {
                      enable = true;
                      ssh = {
                        enable = true;
                        ignoreEmptyHostKeys = true;
                        port = 22;
                        authorizedKeys = [ sshKey ];
                      };
                    };
                    supportedFilesystems = {
                      btrfs = true;
                      vfat = true;
                      zfs = lib.mkForce false;
                    };
                    systemd = {
                      emergencyAccess = true;
                      enable = true;
                      root = "gpt-auto";
                      tpm2.enable = true;
                    };
                    verbose = false;
                  };
                  kernelPackages = pkgs.linuxPackages_latest;
                  loader = {
                    efi.canTouchEfiVariables = true;
                    systemd-boot = {
                      configurationLimit = 10;
                      enable = true;
                    };
                  };
                  supportedFilesystems.zfs = lib.mkForce false;
                };

                disko.devices = {
                  disk = {
                    main = {
                      device = diskDevice;
                      type = "disk";
                      content = {
                        type = "gpt";
                        partitions = {
                          ESP = {
                            size = "1G";
                            type = "EF00";
                            content = {
                              type = "filesystem";
                              format = "vfat";
                              mountpoint = "/boot";
                              mountOptions = [
                                "noatime"
                                "umask=0077"
                              ];
                              extraArgs = [
                                "-n"
                                "ESP"
                              ];
                            };
                          };
                          root = {
                            size = "100%";
                            content = {
                              type = "filesystem";
                              format = "btrfs";
                              mountOptions = [
                                "autodefrag"
                                "compress=zstd:15"
                                "discard=async"
                                "noatime"
                              ];
                              mountpoint = "/";
                              extraArgs = [
                                "--label"
                                "root"
                              ];
                            };
                          };
                        };
                      };
                    };
                  };
                };

                documentation = {
                  doc.enable = false;
                  man.enable = false;
                  nixos.enable = false;
                };

                networking = {
                  extraHosts = ''
                    ${ipAddress} ${fqdn}
                  '';
                  firewall = {
                    enable = true;
                    allowedTCPPorts = [
                      22
                      80
                      443
                      2379
                      2380
                      6443
                    ];
                    allowedUDPPorts = [
                      8285
                      8472
                    ];
                    interfaces.flannelnet.allowedTCPPorts = [ 53 ];
                    interfaces.flannelnet.allowedUDPPorts = [ 53 ];
                  };
                  hostName = hostName;
                  networkmanager.enable = lib.mkForce false;
                  useNetworkd = true;
                  dhcpcd.enable = lib.mkForce false;
                  useDHCP = lib.mkForce false;
                };

                nix = {
                  settings = {
                    experimental-features = [
                      "nix-command"
                      "flakes"
                    ];
                    # extra-sandbox-paths = [ "/var/cache/ccache" ];
                    substituters = [
                      "https://cache.nixos.org?priority=40"
                      "https://nix-community.cachix.org?priority=41"
                      "https://numtide.cachix.org?priority=42"
                      # "https://attic.batonac.com/k3s?priority=43"
                    ];
                    trusted-public-keys = [
                      "cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY="
                      "nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs="
                      "numtide.cachix.org-1:2ps1kLBUWjxIneOy1Ik6cQjb41X0iXVXeHigGmycPPE="
                      "k3s:A8GYNJNy2p/ZMtxVlKuy1nZ8bnZ84PVfqPO6kg6A6qY="
                    ];
                    trusted-users = [
                      "root"
                      "nixos"
                      "@wheel"
                    ];
                  };
                  gc = {
                    automatic = true;
                    dates = "weekly";
                    options = "-d";
                  };
                };

                time.timeZone = timeZone;

                i18n.defaultLocale = locale;

                users.users = {
                  ${username} =
                    { pkgs, ... }:
                    {
                      extraGroups = [
                        "wheel"
                        "kubernetes"
                      ];
                      initialPassword = initialPassword;
                      isNormalUser = true;
                      openssh.authorizedKeys.keys = [ sshKey ];
                    };
                  root = {
                    openssh.authorizedKeys.keys = [ sshKey ];
                  };
                };

                age.secrets = {
                  cloudflare-email = {
                    file = ./secrets/cloudflare-email.age;
                    mode = "0400";
                    owner = "root";
                    group = "root";
                  };
                  cloudflare-dns-api-token = {
                    file = ./secrets/cloudflare-dns-api-token.age;
                    mode = "0400";
                    owner = "root";
                    group = "root";
                  };

                  # Internal Kubernetes PKI (generate .age files via generate-internal-pki.sh)
                  k8s-ca-crt = {
                    file = ./secrets/k8s-ca.crt.age;
                    path = "/var/lib/kubernetes/pki/ca.crt";
                    owner = "root";
                    group = "root";
                    mode = "0400";
                  };
                  k8s-ca-key = {
                    file = ./secrets/k8s-ca.key.age;
                    path = "/var/lib/kubernetes/pki/ca.key";
                    owner = "root";
                    group = "root";
                    mode = "0400";
                  };
                  k8s-apiserver-crt = {
                    file = ./secrets/k8s-apiserver.crt.age;
                    path = "/var/lib/kubernetes/pki/apiserver.crt";
                    owner = "root";
                    group = "root";
                    mode = "0400";
                  };
                  k8s-apiserver-key = {
                    file = ./secrets/k8s-apiserver.key.age;
                    path = "/var/lib/kubernetes/pki/apiserver.key";
                    owner = "root";
                    group = "root";
                    mode = "0400";
                  };
                  k8s-admin-crt = {
                    file = ./secrets/k8s-admin.crt.age;
                    path = "/var/lib/kubernetes/pki/admin.crt";
                    owner = "root";
                    group = "root";
                    mode = "0400";
                  };
                  k8s-admin-key = {
                    file = ./secrets/k8s-admin.key.age;
                    path = "/var/lib/kubernetes/pki/admin.key";
                    owner = "root";
                    group = "root";
                    mode = "0400";
                  };

                  # etcd dedicated PKI (generated via generate-internal-pki.sh)
                  etcd-ca-crt = {
                    file = ./secrets/etcd-ca.crt.age;
                    path = "/var/lib/etcd/pki/ca.crt";
                    owner = "root";
                    group = "root";
                    mode = "0400";
                  };
                  etcd-ca-key = {
                    file = ./secrets/etcd-ca.key.age;
                    path = "/var/lib/etcd/pki/ca.key";
                    owner = "root";
                    group = "root";
                    mode = "0400";
                  };
                  etcd-server-crt = {
                    file = ./secrets/etcd-server.crt.age;
                    path = "/var/lib/etcd/pki/server.crt";
                    owner = "root";
                    group = "root";
                    mode = "0400";
                  };
                  etcd-server-key = {
                    file = ./secrets/etcd-server.key.age;
                    path = "/var/lib/etcd/pki/server.key";
                    owner = "root";
                    group = "root";
                    mode = "0400";
                  };
                  etcd-peer-crt = {
                    file = ./secrets/etcd-peer.crt.age;
                    path = "/var/lib/etcd/pki/peer.crt";
                    owner = "root";
                    group = "root";
                    mode = "0400";
                  };
                  etcd-peer-key = {
                    file = ./secrets/etcd-peer.key.age;
                    path = "/var/lib/etcd/pki/peer.key";
                    owner = "root";
                    group = "root";
                    mode = "0400";
                  };
                  etcd-apiserver-client-crt = {
                    file = ./secrets/etcd-apiserver-client.crt.age;
                    path = "/var/lib/etcd/pki/apiserver-client.crt";
                    owner = "root";
                    group = "root";
                    mode = "0400";
                  };
                  etcd-apiserver-client-key = {
                    file = ./secrets/etcd-apiserver-client.key.age;
                    path = "/var/lib/etcd/pki/apiserver-client.key";
                    owner = "root";
                    group = "root";
                    mode = "0400";
                  };
                  etcd-flannel-client-crt = {
                    file = ./secrets/etcd-flannel-client.crt.age;
                    path = "/var/lib/etcd/pki/flannel-client.crt";
                    owner = "root";
                    group = "root";
                    mode = "0400";
                  };
                  etcd-flannel-client-key = {
                    file = ./secrets/etcd-flannel-client.key.age;
                    path = "/var/lib/etcd/pki/flannel-client.key";
                    owner = "root";
                    group = "root";
                    mode = "0400";
                  };
                };

                environment = {
                  etc = {
                    "cni/net.d/10-crio-bridge.conflist".enable = false;
                    "cni/net.d/99-loopback.conflist".enable = false;

                    # Create cluster-admin kubeconfig using internal admin cert (dual PKI: internal CA + external ACME)
                    "kubernetes/admin.kubeconfig".text = builtins.toJSON {
                      apiVersion = "v1";
                      kind = "Config";
                      clusters = [
                        {
                          name = "local";
                          cluster = {
                            certificate-authority = "/var/lib/kubernetes/pki/ca.crt";
                            server = "https://${fqdn}:6443";
                          };
                        }
                      ];
                      users = [
                        {
                          name = "admin";
                          user = {
                            client-certificate = "/var/lib/kubernetes/pki/admin.crt";
                            client-key = "/var/lib/kubernetes/pki/admin.key";
                          };
                        }
                      ];
                      contexts = [
                        {
                          context = {
                            cluster = "local";
                            user = "admin";
                          };
                          name = "local";
                        }
                      ];
                      current-context = "local";
                    };
                  };

                  # Set system-wide KUBECONFIG to internal admin kubeconfig
                  variables = {
                    KUBECONFIG = "/etc/kubernetes/admin.kubeconfig";
                  };

                  systemPackages = extraPackages ++ [ agenix.packages.x86_64-linux.default ];
                };

                services = {
                  etcd = {
                    advertiseClientUrls = [ "https://${fqdn}:2379" ];
                    discovery = "https://${fqdn}:2380";
                    enable = true;
                    initialAdvertisePeerUrls = [ "https://${ipAddress}:2380" ];
                    initialCluster = [ "${hostName}=https://${ipAddress}:2380" ];
                    initialClusterState = "new";
                    listenClientUrls = [
                      "https://127.0.0.1:2379"
                      "https://${ipAddress}:2379"
                    ];
                    listenPeerUrls = [
                      "https://127.0.0.1:2380"
                      "https://${ipAddress}:2380"
                    ];
                    name = hostName;
                    openFirewall = true;
                    certFile = "/var/lib/etcd/pki/server.crt";
                    keyFile = "/var/lib/etcd/pki/server.key";
                    trustedCaFile = "/var/lib/etcd/pki/ca.crt";
                    peerCertFile = "/var/lib/etcd/pki/peer.crt";
                    peerKeyFile = "/var/lib/etcd/pki/peer.key";
                    peerTrustedCaFile = "/var/lib/etcd/pki/ca.crt";
                  };
                  flannel = {
                    enable = true;
                    network = "10.42.0.0/16";
                    backend = {
                      type = "vxlan";
                      port = 8472;
                    };
                    iface = "ens18";
                    storageBackend = lib.mkForce "etcd";
                    etcd = {
                      endpoints = [ "https://${fqdn}:2379" ];
                      caFile = "/var/lib/etcd/pki/ca.crt";
                      certFile = "/var/lib/etcd/pki/flannel-client.crt";
                      keyFile = "/var/lib/etcd/pki/flannel-client.key";
                    };
                  };
                  kubernetes = {

                    apiserverAddress = "https://${fqdn}:6443";
                    caFile = "/var/lib/acme/${fqdn}/chain.pem";
                    clusterCidr = "10.42.0.0/16";
                    easyCerts = false;
                    masterAddress = fqdn;
                    roles = [
                      "master"
                      "node"
                    ];

                    # Enable addon manager for custom addons
                    addonManager = {
                      enable = true;
                      addons = {
                        # Namespaces
                        cert-manager-namespace = {
                          apiVersion = "v1";
                          kind = "Namespace";
                          metadata = {
                            name = "cert-manager";
                            labels = {
                              "addonmanager.kubernetes.io/mode" = "Reconcile";
                            };
                          };
                        };

                        juicefs-csi-namespace = {
                          apiVersion = "v1";
                          kind = "Namespace";
                          metadata = {
                            name = "juicefs-csi";
                            labels = {
                              "addonmanager.kubernetes.io/mode" = "Reconcile";
                            };
                          };
                        };

                        monitoring-namespace = {
                          apiVersion = "v1";
                          kind = "Namespace";
                          metadata = {
                            name = "monitoring";
                            labels = {
                              "addonmanager.kubernetes.io/mode" = "Reconcile";
                            };
                          };
                        };

                        # Test pod
                        alpine-test = {
                          apiVersion = "v1";
                          kind = "Pod";
                          metadata = {
                            name = "alpine-test";
                            namespace = "default";
                            labels = {
                              "addonmanager.kubernetes.io/mode" = "Reconcile";
                              app = "alpine-test";
                            };
                          };
                          spec = {
                            containers = [
                              {
                                name = "alpine";
                                image = "alpine:latest";
                                command = [
                                  "sleep"
                                  "3600"
                                ];
                                imagePullPolicy = "IfNotPresent";
                                resources = {
                                  requests = {
                                    cpu = "100m";
                                    memory = "64Mi";
                                  };
                                };
                              }
                            ];
                            restartPolicy = "Always";
                          };
                        };

                        # Example nginx deployment
                        nginx-deployment = {
                          apiVersion = "apps/v1";
                          kind = "Deployment";
                          metadata = {
                            name = "nginx";
                            namespace = "default";
                            labels = {
                              "addonmanager.kubernetes.io/mode" = "Reconcile";
                              app = "nginx";
                            };
                          };
                          spec = {
                            replicas = 1;
                            selector = {
                              matchLabels = {
                                app = "nginx";
                              };
                            };
                            template = {
                              metadata = {
                                labels = {
                                  app = "nginx";
                                };
                              };
                              spec = {
                                containers = [
                                  {
                                    name = "nginx";
                                    image = "nginx:1.25";
                                    imagePullPolicy = "IfNotPresent";
                                    ports = [
                                      {
                                        containerPort = 80;
                                      }
                                    ];
                                  }
                                ];
                              };
                            };
                          };
                        };

                        # Service for nginx
                        nginx-service = {
                          apiVersion = "v1";
                          kind = "Service";
                          metadata = {
                            name = "nginx";
                            namespace = "default";
                            labels = {
                              "addonmanager.kubernetes.io/mode" = "Reconcile";
                              app = "nginx";
                            };
                          };
                          spec = {
                            selector = {
                              app = "nginx";
                            };
                            ports = [
                              {
                                name = "http";
                                port = 80;
                                targetPort = 80;
                              }
                            ];
                            type = "ClusterIP";
                          };
                        };

                        # ClusterRoleBinding to give admin permissions to ACME certificate
                        acme-admin-binding = {
                          apiVersion = "rbac.authorization.k8s.io/v1";
                          kind = "ClusterRoleBinding";
                          metadata = {
                            name = "acme-admin";
                            labels = {
                              "addonmanager.kubernetes.io/mode" = "Reconcile";
                            };
                          };
                          subjects = [
                            {
                              kind = "User";
                              name = fqdn; # The certificate subject (Common Name)
                              apiGroup = "rbac.authorization.k8s.io";
                            }
                          ];
                          roleRef = {
                            kind = "ClusterRole";
                            name = "cluster-admin";
                            apiGroup = "rbac.authorization.k8s.io";
                          };
                        };
                      };
                    };

                    addons = {
                      dns = {
                        enable = true;
                      };
                    };

                    apiserver = {
                      advertiseAddress = ipAddress;
                      allowPrivileged = true;
                      authorizationMode = [
                        "Node"
                        "RBAC"
                      ];
                      bindAddress = "0.0.0.0";
                      enable = true;
                      securePort = 6443;
                      serviceClusterIpRange = "10.43.0.0/16";
                      # Switch to internal CA + internal apiserver cert (ACME served via SNI extra flag)
                      serviceAccountKeyFile = "/var/lib/acme/${fqdn}/cert.pem"; # (kept temporary ‚Äì consider separate key later)
                      serviceAccountSigningKeyFile = "/var/lib/acme/${fqdn}/key.pem";
                      tlsCertFile = "/var/lib/kubernetes/pki/apiserver.crt";
                      tlsKeyFile = "/var/lib/kubernetes/pki/apiserver.key";
                      etcd = {
                        servers = [ "https://${fqdn}:2379" ];
                        caFile = "/var/lib/etcd/pki/ca.crt";
                        certFile = "/var/lib/etcd/pki/apiserver-client.crt";
                        keyFile = "/var/lib/etcd/pki/apiserver-client.key";
                      };
                      clientCaFile = "/var/lib/kubernetes/pki/ca.crt";
                      extraFlags = [
                        "--tls-sni-cert-key=${fqdn}=/var/lib/acme/${fqdn}/cert.pem,/var/lib/acme/${fqdn}/key.pem"
                      ];
                    };

                    controllerManager = {
                      enable = true;
                      bindAddress = "0.0.0.0";
                      clusterCidr = "10.42.0.0/16";
                      rootCaFile = "/var/lib/acme/${fqdn}/chain.pem";
                      serviceAccountKeyFile = "/var/lib/acme/${fqdn}/cert.pem";
                      tlsCertFile = "/var/lib/acme/${fqdn}/cert.pem";
                      tlsKeyFile = "/var/lib/acme/${fqdn}/key.pem";
                    };

                    kubeconfig = {
                      caFile = "/var/lib/kubernetes/pki/ca.crt";
                      certFile = "/var/lib/kubernetes/pki/admin.crt";
                      keyFile = "/var/lib/kubernetes/pki/admin.key";
                      server = "https://${fqdn}:6443";
                    };

                    # Seed container images and kubelet config
                    kubelet = {
                      containerRuntimeEndpoint = "unix:///run/crio/crio.sock";
                      seedDockerImages = [
                        (pkgs.dockerTools.pullImage {
                          imageName = "coredns/coredns";
                          imageDigest = "sha256:a0ead06651cf580044aeb0a0feba63591858fb2e43ade8c9dea45a6a89ae7e5e";
                          finalImageTag = "1.10.1";
                          sha256 = "0wg696920smmal7552a2zdhfncndn5kfammfa8bk8l7dz9bhk0y1";
                        })
                        # (pkgs.dockerTools.pullImage {
                        #   imageName = "alpine";
                        #   finalImageTag = "latest";
                        #   sha256 = "sha256-6457d53fb065d6f250e1504b9bc42d5b6c65941d57532c072d929dd0628977d0";
                        # })
                        # (pkgs.dockerTools.pullImage {
                        #   imageName = "nginx";
                        #   finalImageTag = "1.25";
                        #   sha256 = "sha256-4c0fdaa8b6341bfdeca5f18f7837462c80cff90527ee35ef185571e1c327beac";
                        # })
                      ];

                      cni = {
                        packages = with pkgs; [
                          cni-plugins
                          cni-plugin-flannel
                        ];
                        config = [
                          {
                            name = "flannelnet";
                            type = "flannel";
                            cniVersion = pkgs.cni-plugin-flannel.version;
                            delegate = {
                              isDefaultGateway = true;
                              bridge = "flannelnet";
                            };
                          }
                        ];
                      };
                    };

                    scheduler = {
                      enable = true;
                      address = "0.0.0.0";
                      port = 10251;
                    };

                  };

                  lvm.enable = false;

                  openssh = {
                    enable = true;
                    settings = {
                      PermitRootLogin = "yes";
                    };
                  };

                  vscode-server.enable = true;
                };

                programs = {
                  nix-ld.enable = true;
                };

                security = {
                  acme = {
                    acceptTerms = true;
                    defaults.email = "kevin@avu.nu";
                    certs."${fqdn}" = {
                      domain = fqdn;
                      dnsProvider = "cloudflare";
                      credentialFiles = {
                        "CLOUDFLARE_EMAIL_FILE" = config.age.secrets.cloudflare-email.path;
                        "CLOUDFLARE_DNS_API_TOKEN_FILE" = config.age.secrets.cloudflare-dns-api-token.path;
                      };
                      group = "kubernetes";
                      webroot = null;
                    };
                  };
                };

                system.stateVersion = stateVersion;

                systemd = {
                  network = {
                    enable = true;
                    networks."10-wan" = {
                      matchConfig.Name = "ens18";
                      address = [
                        # configure addresses including subnet mask
                        "${ipAddress}/24"
                      ];
                      routes = [
                        # create default routes for IPv4
                        { Gateway = "10.48.4.1"; }
                      ];
                      networkConfig = {
                        IPv6AcceptRA = true;
                      };
                      linkConfig.RequiredForOnline = "routable";
                    };
                  };

                  # Add services to kubernetes group for certificate access
                  services.etcd.serviceConfig.SupplementaryGroups = [ "kubernetes" ];
                  services.flannel.serviceConfig.SupplementaryGroups = [ "kubernetes" ];
                };

                virtualisation = {
                  containers = {
                    enable = true;
                  };
                  cri-o = {
                    enable = true;
                    storageDriver = "btrfs";
                    runtime = "crun";
                    settings = {
                      crio = {
                        image = {
                          # Configure default registries
                          registries = {
                            "docker.io" = {
                              blocked = false;
                              insecure = false;
                              location = "docker.io";
                              mirror = [ ];
                              prefix = "docker.io";
                            };
                            "quay.io" = {
                              blocked = false;
                              insecure = false;
                              location = "quay.io";
                              mirror = [ ];
                              prefix = "quay.io";
                            };
                            "gcr.io" = {
                              blocked = false;
                              insecure = false;
                              location = "gcr.io";
                              mirror = [ ];
                              prefix = "gcr.io";
                            };
                            "registry.k8s.io" = {
                              blocked = false;
                              insecure = false;
                              location = "registry.k8s.io";
                              mirror = [ ];
                              prefix = "registry.k8s.io";
                            };
                          };
                        };
                        network = {
                          plugin_dirs = [
                            "${pkgs.cni-plugins}/bin"
                            "${pkgs.cni-plugin-flannel}/bin"
                          ];
                          network_dir = "/etc/cni/net.d";
                        };
                        runtime = {
                          cgroup_manager = "systemd";
                          default_runtime = "crun";
                          pause_image = "rancher/mirrored-pause:3.6";
                          pause_image_auth_file = "";
                          pause_command = "/pause";
                          conmon_cgroup = "pod";
                          manage_ns_lifecycle = true;
                        };
                      };
                    };
                  };
                };
              }
            )
          ];
        };
      };
    };
}
